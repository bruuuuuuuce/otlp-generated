/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: opentelemetry/proto/metrics/v1/metrics.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../common/v1/common";
import * as dependency_2 from "./../../resource/v1/resource";
import * as pb_1 from "google-protobuf";
export namespace opentelemetry.proto.metrics.v1 {
    export enum AggregationTemporality {
        AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
        AGGREGATION_TEMPORALITY_DELTA = 1,
        AGGREGATION_TEMPORALITY_CUMULATIVE = 2
    }
    export enum DataPointFlags {
        FLAG_NONE = 0,
        FLAG_NO_RECORDED_VALUE = 1
    }
    export class MetricsData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            resource_metrics?: ResourceMetrics[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource_metrics" in data && data.resource_metrics != undefined) {
                    this.resource_metrics = data.resource_metrics;
                }
            }
        }
        get resource_metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, ResourceMetrics, 1) as ResourceMetrics[];
        }
        set resource_metrics(value: ResourceMetrics[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            resource_metrics?: ReturnType<typeof ResourceMetrics.prototype.toObject>[];
        }): MetricsData {
            const message = new MetricsData({});
            if (data.resource_metrics != null) {
                message.resource_metrics = data.resource_metrics.map(item => ResourceMetrics.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                resource_metrics?: ReturnType<typeof ResourceMetrics.prototype.toObject>[];
            } = {};
            if (this.resource_metrics != null) {
                data.resource_metrics = this.resource_metrics.map((item: ResourceMetrics) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.resource_metrics.length)
                writer.writeRepeatedMessage(1, this.resource_metrics, (item: ResourceMetrics) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetricsData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MetricsData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource_metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ResourceMetrics.deserialize(reader), ResourceMetrics));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MetricsData {
            return MetricsData.deserialize(bytes);
        }
    }
    export class ResourceMetrics extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            resource?: dependency_2.opentelemetry.proto.resource.v1.Resource;
            scope_metrics?: ScopeMetrics[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource" in data && data.resource != undefined) {
                    this.resource = data.resource;
                }
                if ("scope_metrics" in data && data.scope_metrics != undefined) {
                    this.scope_metrics = data.scope_metrics;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get resource() {
            return pb_1.Message.getWrapperField(this, dependency_2.opentelemetry.proto.resource.v1.Resource, 1) as dependency_2.opentelemetry.proto.resource.v1.Resource;
        }
        set resource(value: dependency_2.opentelemetry.proto.resource.v1.Resource) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_resource() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get scope_metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, ScopeMetrics, 2) as ScopeMetrics[];
        }
        set scope_metrics(value: ScopeMetrics[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
            scope_metrics?: ReturnType<typeof ScopeMetrics.prototype.toObject>[];
            schema_url?: string;
        }): ResourceMetrics {
            const message = new ResourceMetrics({});
            if (data.resource != null) {
                message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.fromObject(data.resource);
            }
            if (data.scope_metrics != null) {
                message.scope_metrics = data.scope_metrics.map(item => ScopeMetrics.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
                scope_metrics?: ReturnType<typeof ScopeMetrics.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.resource != null) {
                data.resource = this.resource.toObject();
            }
            if (this.scope_metrics != null) {
                data.scope_metrics = this.scope_metrics.map((item: ScopeMetrics) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_resource)
                writer.writeMessage(1, this.resource, () => this.resource.serialize(writer));
            if (this.scope_metrics.length)
                writer.writeRepeatedMessage(2, this.scope_metrics, (item: ScopeMetrics) => item.serialize(writer));
            if (this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResourceMetrics {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResourceMetrics();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource, () => message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.scope_metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ScopeMetrics.deserialize(reader), ScopeMetrics));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResourceMetrics {
            return ResourceMetrics.deserialize(bytes);
        }
    }
    export class ScopeMetrics extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            scope?: dependency_1.opentelemetry.proto.common.v1.InstrumentationScope;
            metrics?: Metric[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("scope" in data && data.scope != undefined) {
                    this.scope = data.scope;
                }
                if ("metrics" in data && data.metrics != undefined) {
                    this.metrics = data.metrics;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get scope() {
            return pb_1.Message.getWrapperField(this, dependency_1.opentelemetry.proto.common.v1.InstrumentationScope, 1) as dependency_1.opentelemetry.proto.common.v1.InstrumentationScope;
        }
        set scope(value: dependency_1.opentelemetry.proto.common.v1.InstrumentationScope) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_scope() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, Metric, 2) as Metric[];
        }
        set metrics(value: Metric[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            scope?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationScope.prototype.toObject>;
            metrics?: ReturnType<typeof Metric.prototype.toObject>[];
            schema_url?: string;
        }): ScopeMetrics {
            const message = new ScopeMetrics({});
            if (data.scope != null) {
                message.scope = dependency_1.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(data.scope);
            }
            if (data.metrics != null) {
                message.metrics = data.metrics.map(item => Metric.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                scope?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationScope.prototype.toObject>;
                metrics?: ReturnType<typeof Metric.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.scope != null) {
                data.scope = this.scope.toObject();
            }
            if (this.metrics != null) {
                data.metrics = this.metrics.map((item: Metric) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_scope)
                writer.writeMessage(1, this.scope, () => this.scope.serialize(writer));
            if (this.metrics.length)
                writer.writeRepeatedMessage(2, this.metrics, (item: Metric) => item.serialize(writer));
            if (this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ScopeMetrics {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ScopeMetrics();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.scope, () => message.scope = dependency_1.opentelemetry.proto.common.v1.InstrumentationScope.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Metric.deserialize(reader), Metric));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ScopeMetrics {
            return ScopeMetrics.deserialize(bytes);
        }
    }
    export class Metric extends pb_1.Message {
        #one_of_decls: number[][] = [[5, 7, 9, 10, 11]];
        constructor(data?: any[] | ({
            name?: string;
            description?: string;
            unit?: string;
        } & (({
            gauge?: Gauge;
            sum?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            gauge?: never;
            sum?: Sum;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            gauge?: never;
            sum?: never;
            histogram?: Histogram;
            exponential_histogram?: never;
            summary?: never;
        } | {
            gauge?: never;
            sum?: never;
            histogram?: never;
            exponential_histogram?: ExponentialHistogram;
            summary?: never;
        } | {
            gauge?: never;
            sum?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: Summary;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("unit" in data && data.unit != undefined) {
                    this.unit = data.unit;
                }
                if ("gauge" in data && data.gauge != undefined) {
                    this.gauge = data.gauge;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("histogram" in data && data.histogram != undefined) {
                    this.histogram = data.histogram;
                }
                if ("exponential_histogram" in data && data.exponential_histogram != undefined) {
                    this.exponential_histogram = data.exponential_histogram;
                }
                if ("summary" in data && data.summary != undefined) {
                    this.summary = data.summary;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get unit() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set unit(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get gauge() {
            return pb_1.Message.getWrapperField(this, Gauge, 5) as Gauge;
        }
        set gauge(value: Gauge) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_gauge() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get sum() {
            return pb_1.Message.getWrapperField(this, Sum, 7) as Sum;
        }
        set sum(value: Sum) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_sum() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get histogram() {
            return pb_1.Message.getWrapperField(this, Histogram, 9) as Histogram;
        }
        set histogram(value: Histogram) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_histogram() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get exponential_histogram() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogram, 10) as ExponentialHistogram;
        }
        set exponential_histogram(value: ExponentialHistogram) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_exponential_histogram() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get summary() {
            return pb_1.Message.getWrapperField(this, Summary, 11) as Summary;
        }
        set summary(value: Summary) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_summary() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get data() {
            const cases: {
                [index: number]: "none" | "gauge" | "sum" | "histogram" | "exponential_histogram" | "summary";
            } = {
                0: "none",
                5: "gauge",
                7: "sum",
                9: "histogram",
                10: "exponential_histogram",
                11: "summary"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5, 7, 9, 10, 11])];
        }
        static fromObject(data: {
            name?: string;
            description?: string;
            unit?: string;
            gauge?: ReturnType<typeof Gauge.prototype.toObject>;
            sum?: ReturnType<typeof Sum.prototype.toObject>;
            histogram?: ReturnType<typeof Histogram.prototype.toObject>;
            exponential_histogram?: ReturnType<typeof ExponentialHistogram.prototype.toObject>;
            summary?: ReturnType<typeof Summary.prototype.toObject>;
        }): Metric {
            const message = new Metric({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.unit != null) {
                message.unit = data.unit;
            }
            if (data.gauge != null) {
                message.gauge = Gauge.fromObject(data.gauge);
            }
            if (data.sum != null) {
                message.sum = Sum.fromObject(data.sum);
            }
            if (data.histogram != null) {
                message.histogram = Histogram.fromObject(data.histogram);
            }
            if (data.exponential_histogram != null) {
                message.exponential_histogram = ExponentialHistogram.fromObject(data.exponential_histogram);
            }
            if (data.summary != null) {
                message.summary = Summary.fromObject(data.summary);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                description?: string;
                unit?: string;
                gauge?: ReturnType<typeof Gauge.prototype.toObject>;
                sum?: ReturnType<typeof Sum.prototype.toObject>;
                histogram?: ReturnType<typeof Histogram.prototype.toObject>;
                exponential_histogram?: ReturnType<typeof ExponentialHistogram.prototype.toObject>;
                summary?: ReturnType<typeof Summary.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.unit != null) {
                data.unit = this.unit;
            }
            if (this.gauge != null) {
                data.gauge = this.gauge.toObject();
            }
            if (this.sum != null) {
                data.sum = this.sum.toObject();
            }
            if (this.histogram != null) {
                data.histogram = this.histogram.toObject();
            }
            if (this.exponential_histogram != null) {
                data.exponential_histogram = this.exponential_histogram.toObject();
            }
            if (this.summary != null) {
                data.summary = this.summary.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.description.length)
                writer.writeString(2, this.description);
            if (this.unit.length)
                writer.writeString(3, this.unit);
            if (this.has_gauge)
                writer.writeMessage(5, this.gauge, () => this.gauge.serialize(writer));
            if (this.has_sum)
                writer.writeMessage(7, this.sum, () => this.sum.serialize(writer));
            if (this.has_histogram)
                writer.writeMessage(9, this.histogram, () => this.histogram.serialize(writer));
            if (this.has_exponential_histogram)
                writer.writeMessage(10, this.exponential_histogram, () => this.exponential_histogram.serialize(writer));
            if (this.has_summary)
                writer.writeMessage(11, this.summary, () => this.summary.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Metric {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Metric();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.description = reader.readString();
                        break;
                    case 3:
                        message.unit = reader.readString();
                        break;
                    case 5:
                        reader.readMessage(message.gauge, () => message.gauge = Gauge.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.sum, () => message.sum = Sum.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.histogram, () => message.histogram = Histogram.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.exponential_histogram, () => message.exponential_histogram = ExponentialHistogram.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.summary, () => message.summary = Summary.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Metric {
            return Metric.deserialize(bytes);
        }
    }
    export class Gauge extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data_points?: NumberDataPoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, NumberDataPoint, 1) as NumberDataPoint[];
        }
        set data_points(value: NumberDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
        }): Gauge {
            const message = new Gauge({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => NumberDataPoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: NumberDataPoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points.length)
                writer.writeRepeatedMessage(1, this.data_points, (item: NumberDataPoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Gauge {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Gauge();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, NumberDataPoint.deserialize(reader), NumberDataPoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Gauge {
            return Gauge.deserialize(bytes);
        }
    }
    export class Sum extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data_points?: NumberDataPoint[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
                if ("is_monotonic" in data && data.is_monotonic != undefined) {
                    this.is_monotonic = data.is_monotonic;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, NumberDataPoint, 1) as NumberDataPoint[];
        }
        set data_points(value: NumberDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getFieldWithDefault(this, 2, AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        get is_monotonic() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set is_monotonic(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }): Sum {
            const message = new Sum({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => NumberDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            if (data.is_monotonic != null) {
                message.is_monotonic = data.is_monotonic;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
                is_monotonic?: boolean;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: NumberDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            if (this.is_monotonic != null) {
                data.is_monotonic = this.is_monotonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points.length)
                writer.writeRepeatedMessage(1, this.data_points, (item: NumberDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
                writer.writeEnum(2, this.aggregation_temporality);
            if (this.is_monotonic != false)
                writer.writeBool(3, this.is_monotonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Sum {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Sum();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, NumberDataPoint.deserialize(reader), NumberDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    case 3:
                        message.is_monotonic = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Sum {
            return Sum.deserialize(bytes);
        }
    }
    export class Histogram extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data_points?: HistogramDataPoint[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, HistogramDataPoint, 1) as HistogramDataPoint[];
        }
        set data_points(value: HistogramDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getFieldWithDefault(this, 2, AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof HistogramDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
        }): Histogram {
            const message = new Histogram({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => HistogramDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof HistogramDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: HistogramDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points.length)
                writer.writeRepeatedMessage(1, this.data_points, (item: HistogramDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
                writer.writeEnum(2, this.aggregation_temporality);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Histogram {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Histogram();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistogramDataPoint.deserialize(reader), HistogramDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Histogram {
            return Histogram.deserialize(bytes);
        }
    }
    export class ExponentialHistogram extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data_points?: ExponentialHistogramDataPoint[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, ExponentialHistogramDataPoint, 1) as ExponentialHistogramDataPoint[];
        }
        set data_points(value: ExponentialHistogramDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getFieldWithDefault(this, 2, AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof ExponentialHistogramDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
        }): ExponentialHistogram {
            const message = new ExponentialHistogram({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => ExponentialHistogramDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof ExponentialHistogramDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: ExponentialHistogramDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points.length)
                writer.writeRepeatedMessage(1, this.data_points, (item: ExponentialHistogramDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
                writer.writeEnum(2, this.aggregation_temporality);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExponentialHistogram {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExponentialHistogram();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ExponentialHistogramDataPoint.deserialize(reader), ExponentialHistogramDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExponentialHistogram {
            return ExponentialHistogram.deserialize(bytes);
        }
    }
    export class Summary extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data_points?: SummaryDataPoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, SummaryDataPoint, 1) as SummaryDataPoint[];
        }
        set data_points(value: SummaryDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof SummaryDataPoint.prototype.toObject>[];
        }): Summary {
            const message = new Summary({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => SummaryDataPoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof SummaryDataPoint.prototype.toObject>[];
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: SummaryDataPoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points.length)
                writer.writeRepeatedMessage(1, this.data_points, (item: SummaryDataPoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Summary {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Summary();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SummaryDataPoint.deserialize(reader), SummaryDataPoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Summary {
            return Summary.deserialize(bytes);
        }
    }
    export class NumberDataPoint extends pb_1.Message {
        #one_of_decls: number[][] = [[4, 6]];
        constructor(data?: any[] | ({
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            exemplars?: Exemplar[];
            flags?: number;
        } & (({
            as_double?: number;
            as_int?: never;
        } | {
            as_double?: never;
            as_int?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("as_double" in data && data.as_double != undefined) {
                    this.as_double = data.as_double;
                }
                if ("as_int" in data && data.as_int != undefined) {
                    this.as_int = data.as_int;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get as_double() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set as_double(value: number) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_as_double() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get as_int() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set as_int(value: number) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[0], value);
        }
        get has_as_int() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 5) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get value() {
            const cases: {
                [index: number]: "none" | "as_double" | "as_int";
            } = {
                0: "none",
                4: "as_double",
                6: "as_int"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4, 6])];
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            as_double?: number;
            as_int?: number;
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            flags?: number;
        }): NumberDataPoint {
            const message = new NumberDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.as_double != null) {
                message.as_double = data.as_double;
            }
            if (data.as_int != null) {
                message.as_int = data.as_int;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                as_double?: number;
                as_int?: number;
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
                flags?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.as_double != null) {
                data.as_double = this.as_double;
            }
            if (this.as_int != null) {
                data.as_int = this.as_int;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes.length)
                writer.writeRepeatedMessage(7, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano != 0)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano != 0)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.has_as_double)
                writer.writeDouble(4, this.as_double);
            if (this.has_as_int)
                writer.writeSfixed64(6, this.as_int);
            if (this.exemplars.length)
                writer.writeRepeatedMessage(5, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (this.flags != 0)
                writer.writeUint32(8, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NumberDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NumberDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.as_double = reader.readDouble();
                        break;
                    case 6:
                        message.as_int = reader.readSfixed64();
                        break;
                    case 5:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Exemplar.deserialize(reader), Exemplar));
                        break;
                    case 8:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NumberDataPoint {
            return NumberDataPoint.deserialize(bytes);
        }
    }
    export class HistogramDataPoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: Exemplar[];
            flags?: number;
            min?: number;
            max?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9, 6, 7, 8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("bucket_counts" in data && data.bucket_counts != undefined) {
                    this.bucket_counts = data.bucket_counts;
                }
                if ("explicit_bounds" in data && data.explicit_bounds != undefined) {
                    this.explicit_bounds = data.explicit_bounds;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 9) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get bucket_counts() {
            return pb_1.Message.getFieldWithDefault(this, 6, []) as number[];
        }
        set bucket_counts(value: number[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get explicit_bounds() {
            return pb_1.Message.getFieldWithDefault(this, 7, []) as number[];
        }
        set explicit_bounds(value: number[]) {
            pb_1.Message.setField(this, 7, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 8) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            flags?: number;
            min?: number;
            max?: number;
        }): HistogramDataPoint {
            const message = new HistogramDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.bucket_counts != null) {
                message.bucket_counts = data.bucket_counts;
            }
            if (data.explicit_bounds != null) {
                message.explicit_bounds = data.explicit_bounds;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                bucket_counts?: number[];
                explicit_bounds?: number[];
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
                flags?: number;
                min?: number;
                max?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.bucket_counts != null) {
                data.bucket_counts = this.bucket_counts;
            }
            if (this.explicit_bounds != null) {
                data.explicit_bounds = this.explicit_bounds;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes.length)
                writer.writeRepeatedMessage(9, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano != 0)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano != 0)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count != 0)
                writer.writeFixed64(4, this.count);
            if (this.bucket_counts.length)
                writer.writePackedFixed64(6, this.bucket_counts);
            if (this.explicit_bounds.length)
                writer.writePackedDouble(7, this.explicit_bounds);
            if (this.exemplars.length)
                writer.writeRepeatedMessage(8, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (this.flags != 0)
                writer.writeUint32(10, this.flags);
            if (this.min != 0)
                writer.writeDouble(11, this.min);
            if (this.max != 0)
                writer.writeDouble(12, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistogramDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistogramDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 9:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 9, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 6:
                        message.bucket_counts = reader.readPackedFixed64();
                        break;
                    case 7:
                        message.explicit_bounds = reader.readPackedDouble();
                        break;
                    case 8:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Exemplar.deserialize(reader), Exemplar));
                        break;
                    case 10:
                        message.flags = reader.readUint32();
                        break;
                    case 11:
                        message.min = reader.readDouble();
                        break;
                    case 12:
                        message.max = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HistogramDataPoint {
            return HistogramDataPoint.deserialize(bytes);
        }
    }
    export class ExponentialHistogramDataPoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            scale?: number;
            zero_count?: number;
            positive?: ExponentialHistogramDataPoint.Buckets;
            negative?: ExponentialHistogramDataPoint.Buckets;
            flags?: number;
            exemplars?: Exemplar[];
            min?: number;
            max?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("scale" in data && data.scale != undefined) {
                    this.scale = data.scale;
                }
                if ("zero_count" in data && data.zero_count != undefined) {
                    this.zero_count = data.zero_count;
                }
                if ("positive" in data && data.positive != undefined) {
                    this.positive = data.positive;
                }
                if ("negative" in data && data.negative != undefined) {
                    this.negative = data.negative;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get scale() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set scale(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get zero_count() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set zero_count(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get positive() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogramDataPoint.Buckets, 8) as ExponentialHistogramDataPoint.Buckets;
        }
        set positive(value: ExponentialHistogramDataPoint.Buckets) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_positive() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get negative() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogramDataPoint.Buckets, 9) as ExponentialHistogramDataPoint.Buckets;
        }
        set negative(value: ExponentialHistogramDataPoint.Buckets) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_negative() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 11) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setField(this, 13, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            scale?: number;
            zero_count?: number;
            positive?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
            negative?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
            flags?: number;
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            min?: number;
            max?: number;
        }): ExponentialHistogramDataPoint {
            const message = new ExponentialHistogramDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.scale != null) {
                message.scale = data.scale;
            }
            if (data.zero_count != null) {
                message.zero_count = data.zero_count;
            }
            if (data.positive != null) {
                message.positive = ExponentialHistogramDataPoint.Buckets.fromObject(data.positive);
            }
            if (data.negative != null) {
                message.negative = ExponentialHistogramDataPoint.Buckets.fromObject(data.negative);
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                scale?: number;
                zero_count?: number;
                positive?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
                negative?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
                flags?: number;
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
                min?: number;
                max?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.scale != null) {
                data.scale = this.scale;
            }
            if (this.zero_count != null) {
                data.zero_count = this.zero_count;
            }
            if (this.positive != null) {
                data.positive = this.positive.toObject();
            }
            if (this.negative != null) {
                data.negative = this.negative.toObject();
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes.length)
                writer.writeRepeatedMessage(1, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano != 0)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano != 0)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count != 0)
                writer.writeFixed64(4, this.count);
            if (this.sum != 0)
                writer.writeDouble(5, this.sum);
            if (this.scale != 0)
                writer.writeSint32(6, this.scale);
            if (this.zero_count != 0)
                writer.writeFixed64(7, this.zero_count);
            if (this.has_positive)
                writer.writeMessage(8, this.positive, () => this.positive.serialize(writer));
            if (this.has_negative)
                writer.writeMessage(9, this.negative, () => this.negative.serialize(writer));
            if (this.flags != 0)
                writer.writeUint32(10, this.flags);
            if (this.exemplars.length)
                writer.writeRepeatedMessage(11, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (this.min != 0)
                writer.writeDouble(12, this.min);
            if (this.max != 0)
                writer.writeDouble(13, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExponentialHistogramDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExponentialHistogramDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readDouble();
                        break;
                    case 6:
                        message.scale = reader.readSint32();
                        break;
                    case 7:
                        message.zero_count = reader.readFixed64();
                        break;
                    case 8:
                        reader.readMessage(message.positive, () => message.positive = ExponentialHistogramDataPoint.Buckets.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.negative, () => message.negative = ExponentialHistogramDataPoint.Buckets.deserialize(reader));
                        break;
                    case 10:
                        message.flags = reader.readUint32();
                        break;
                    case 11:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 11, Exemplar.deserialize(reader), Exemplar));
                        break;
                    case 12:
                        message.min = reader.readDouble();
                        break;
                    case 13:
                        message.max = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExponentialHistogramDataPoint {
            return ExponentialHistogramDataPoint.deserialize(bytes);
        }
    }
    export namespace ExponentialHistogramDataPoint {
        export class Buckets extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                offset?: number;
                bucket_counts?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("offset" in data && data.offset != undefined) {
                        this.offset = data.offset;
                    }
                    if ("bucket_counts" in data && data.bucket_counts != undefined) {
                        this.bucket_counts = data.bucket_counts;
                    }
                }
            }
            get offset() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set offset(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get bucket_counts() {
                return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
            }
            set bucket_counts(value: number[]) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                offset?: number;
                bucket_counts?: number[];
            }): Buckets {
                const message = new Buckets({});
                if (data.offset != null) {
                    message.offset = data.offset;
                }
                if (data.bucket_counts != null) {
                    message.bucket_counts = data.bucket_counts;
                }
                return message;
            }
            toObject() {
                const data: {
                    offset?: number;
                    bucket_counts?: number[];
                } = {};
                if (this.offset != null) {
                    data.offset = this.offset;
                }
                if (this.bucket_counts != null) {
                    data.bucket_counts = this.bucket_counts;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.offset != 0)
                    writer.writeSint32(1, this.offset);
                if (this.bucket_counts.length)
                    writer.writePackedUint64(2, this.bucket_counts);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Buckets {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Buckets();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.offset = reader.readSint32();
                            break;
                        case 2:
                            message.bucket_counts = reader.readPackedUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Buckets {
                return Buckets.deserialize(bytes);
            }
        }
    }
    export class SummaryDataPoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            quantile_values?: SummaryDataPoint.ValueAtQuantile[];
            flags?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("quantile_values" in data && data.quantile_values != undefined) {
                    this.quantile_values = data.quantile_values;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get quantile_values() {
            return pb_1.Message.getRepeatedWrapperField(this, SummaryDataPoint.ValueAtQuantile, 6) as SummaryDataPoint.ValueAtQuantile[];
        }
        set quantile_values(value: SummaryDataPoint.ValueAtQuantile[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            quantile_values?: ReturnType<typeof SummaryDataPoint.ValueAtQuantile.prototype.toObject>[];
            flags?: number;
        }): SummaryDataPoint {
            const message = new SummaryDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.quantile_values != null) {
                message.quantile_values = data.quantile_values.map(item => SummaryDataPoint.ValueAtQuantile.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                quantile_values?: ReturnType<typeof SummaryDataPoint.ValueAtQuantile.prototype.toObject>[];
                flags?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.quantile_values != null) {
                data.quantile_values = this.quantile_values.map((item: SummaryDataPoint.ValueAtQuantile) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes.length)
                writer.writeRepeatedMessage(7, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano != 0)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano != 0)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count != 0)
                writer.writeFixed64(4, this.count);
            if (this.sum != 0)
                writer.writeDouble(5, this.sum);
            if (this.quantile_values.length)
                writer.writeRepeatedMessage(6, this.quantile_values, (item: SummaryDataPoint.ValueAtQuantile) => item.serialize(writer));
            if (this.flags != 0)
                writer.writeUint32(8, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SummaryDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SummaryDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readDouble();
                        break;
                    case 6:
                        reader.readMessage(message.quantile_values, () => pb_1.Message.addToRepeatedWrapperField(message, 6, SummaryDataPoint.ValueAtQuantile.deserialize(reader), SummaryDataPoint.ValueAtQuantile));
                        break;
                    case 8:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SummaryDataPoint {
            return SummaryDataPoint.deserialize(bytes);
        }
    }
    export namespace SummaryDataPoint {
        export class ValueAtQuantile extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                quantile?: number;
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("quantile" in data && data.quantile != undefined) {
                        this.quantile = data.quantile;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get quantile() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set quantile(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                quantile?: number;
                value?: number;
            }): ValueAtQuantile {
                const message = new ValueAtQuantile({});
                if (data.quantile != null) {
                    message.quantile = data.quantile;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    quantile?: number;
                    value?: number;
                } = {};
                if (this.quantile != null) {
                    data.quantile = this.quantile;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.quantile != 0)
                    writer.writeDouble(1, this.quantile);
                if (this.value != 0)
                    writer.writeDouble(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValueAtQuantile {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValueAtQuantile();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.quantile = reader.readDouble();
                            break;
                        case 2:
                            message.value = reader.readDouble();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ValueAtQuantile {
                return ValueAtQuantile.deserialize(bytes);
            }
        }
    }
    export class Exemplar extends pb_1.Message {
        #one_of_decls: number[][] = [[3, 6]];
        constructor(data?: any[] | ({
            filtered_attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            time_unix_nano?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        } & (({
            as_double?: number;
            as_int?: never;
        } | {
            as_double?: never;
            as_int?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("filtered_attributes" in data && data.filtered_attributes != undefined) {
                    this.filtered_attributes = data.filtered_attributes;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("as_double" in data && data.as_double != undefined) {
                    this.as_double = data.as_double;
                }
                if ("as_int" in data && data.as_int != undefined) {
                    this.as_int = data.as_int;
                }
                if ("span_id" in data && data.span_id != undefined) {
                    this.span_id = data.span_id;
                }
                if ("trace_id" in data && data.trace_id != undefined) {
                    this.trace_id = data.trace_id;
                }
            }
        }
        get filtered_attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set filtered_attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get as_double() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set as_double(value: number) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_as_double() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get as_int() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set as_int(value: number) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[0], value);
        }
        get has_as_int() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get span_id() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set span_id(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get trace_id() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set trace_id(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get value() {
            const cases: {
                [index: number]: "none" | "as_double" | "as_int";
            } = {
                0: "none",
                3: "as_double",
                6: "as_int"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3, 6])];
        }
        static fromObject(data: {
            filtered_attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            time_unix_nano?: number;
            as_double?: number;
            as_int?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        }): Exemplar {
            const message = new Exemplar({});
            if (data.filtered_attributes != null) {
                message.filtered_attributes = data.filtered_attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.as_double != null) {
                message.as_double = data.as_double;
            }
            if (data.as_int != null) {
                message.as_int = data.as_int;
            }
            if (data.span_id != null) {
                message.span_id = data.span_id;
            }
            if (data.trace_id != null) {
                message.trace_id = data.trace_id;
            }
            return message;
        }
        toObject() {
            const data: {
                filtered_attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                time_unix_nano?: number;
                as_double?: number;
                as_int?: number;
                span_id?: Uint8Array;
                trace_id?: Uint8Array;
            } = {};
            if (this.filtered_attributes != null) {
                data.filtered_attributes = this.filtered_attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.as_double != null) {
                data.as_double = this.as_double;
            }
            if (this.as_int != null) {
                data.as_int = this.as_int;
            }
            if (this.span_id != null) {
                data.span_id = this.span_id;
            }
            if (this.trace_id != null) {
                data.trace_id = this.trace_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.filtered_attributes.length)
                writer.writeRepeatedMessage(7, this.filtered_attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.time_unix_nano != 0)
                writer.writeFixed64(2, this.time_unix_nano);
            if (this.has_as_double)
                writer.writeDouble(3, this.as_double);
            if (this.has_as_int)
                writer.writeSfixed64(6, this.as_int);
            if (this.span_id.length)
                writer.writeBytes(4, this.span_id);
            if (this.trace_id.length)
                writer.writeBytes(5, this.trace_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Exemplar {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Exemplar();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.filtered_attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.as_double = reader.readDouble();
                        break;
                    case 6:
                        message.as_int = reader.readSfixed64();
                        break;
                    case 4:
                        message.span_id = reader.readBytes();
                        break;
                    case 5:
                        message.trace_id = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Exemplar {
            return Exemplar.deserialize(bytes);
        }
    }
}
